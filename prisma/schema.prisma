// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum UserRole {
  student
  landlord
  admin
  staff
  super_admin
}

enum ListingStatus {
  available
  rented
  pending
  inactive
}

enum VerificationStatus {
  pending
  verified
  rejected
}

enum MessageType {
  text
  image
  file
  system
}

enum PropertyType {
  apartment
  house
  dorm
  studio
  shared_room
  private_room
}

enum GenderPreference {
  male
  female
  coed
  any
}

model User {
  id            String             @id @default(uuid())
  email         String             @unique
  password      String? // Nullable for OAuth users
  name          String?
  role          UserRole           @default(student)
  profileImage  String?
  bio           String?
  phone         String?
  preferences   Json? // Store user preferences as JSON
  verification  VerificationStatus @default(pending)
  emailVerified Boolean            @default(false)

  // Supabase Auth integration
  supabaseUserId String? @unique // Links to auth.users.id
  oauthProvider  String? // "google" | "email" | null

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  listings                    Listing[]       @relation("LandlordListings")
  favorites                   Favorite[]
  reviewsGiven                Review[]        @relation("ReviewerReviews")
  reviewsReceived             Review[]        @relation("RevieweeReviews")
  conversationsAsParticipant1 Conversation[]  @relation("ConversationParticipant1")
  conversationsAsParticipant2 Conversation[]  @relation("ConversationParticipant2")
  sentMessages                Message[]       @relation("MessageSender")
  savedSearches               SavedSearch[]
  searchHistory               SearchHistory[]

  @@map("users")
}

model Listing {
  id               String        @id @default(uuid())
  title            String
  description      String        @db.Text
  price            Float
  bedrooms         Int
  bathrooms        Float
  squareFeet       Int?
  city             String
  state            String
  zip              String?
  address          String?
  latitude         Float?
  longitude        Float?
  amenities        String[] // Array of amenities
  images           String[] // Array of image URLs
  status           ListingStatus @default(available)
  availabilityDate DateTime
  landlordId       String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Advanced search fields
  propertyType       PropertyType?
  petFriendly        Boolean           @default(false)
  smokingAllowed     Boolean           @default(false)
  genderPreference   GenderPreference? @default(any)
  parkingAvailable   Boolean           @default(false)
  walkabilityScore   Int?
  nearbyUniversities String[] // Array of university names
  nearbyTransit      String[] // Array of transit station names
  viewCount          Int               @default(0) // For popularity sorting

  // Additional listing details
  billsIncluded      Boolean?          @default(false)
  securityDeposit     Float?
  roomFurnishing     String? // "furnished" | "unfurnished" | "partially_furnished"
  minStayMonths      Int?
  maxStayMonths      Int?
  currentRoomiesCount Int?             @default(0)

  // Relations
  landlord      User           @relation("LandlordListings", fields: [landlordId], references: [id], onDelete: Cascade)
  favorites     Favorite[]
  reviews       Review[]
  conversations Conversation[]

  @@index([landlordId])
  @@index([city])
  @@index([state])
  @@index([status])
  @@index([status, createdAt]) // For active listings
  @@index([status, price]) // For price sorting
  @@index([city, state, status]) // For location + status queries
  @@index([propertyType, status]) // For property type filtering
  @@index([price])
  @@index([bedrooms])
  @@index([bathrooms])
  @@index([squareFeet])
  @@index([propertyType])
  @@index([petFriendly])
  @@index([latitude, longitude]) // For geospatial search
  @@index([viewCount]) // For popularity sorting
  // Phase 2: Additional composite indexes for common query patterns
  @@index([status, city, state, price]) // Multi-column search with price
  @@index([status, propertyType, petFriendly]) // Filter combinations
  @@index([landlordId, status, createdAt]) // Landlord dashboard queries
  @@index([availabilityDate, status]) // Availability searches
  @@index([status, bedrooms, bathrooms]) // Bedroom/bathroom filtering
  @@index([status, price, createdAt]) // Price and date sorting
  @@map("listings")
}

model Favorite {
  userId    String
  listingId String
  createdAt DateTime @default(now())

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@id([userId, listingId])
  @@index([userId])
  @@index([listingId])
  @@map("favorites")
}

model Review {
  id         String   @id @default(uuid())
  reviewerId String
  revieweeId String
  listingId  String?
  rating     Int // Rating out of 5
  comment    String?  @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  reviewer User     @relation("ReviewerReviews", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewee User     @relation("RevieweeReviews", fields: [revieweeId], references: [id], onDelete: Cascade)
  listing  Listing? @relation(fields: [listingId], references: [id], onDelete: SetNull)

  @@unique([reviewerId, revieweeId])
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([revieweeId, createdAt]) // For user reviews
  @@index([listingId])
  @@index([listingId, createdAt]) // For listing reviews
  @@map("reviews")
}

model Conversation {
  id              String    @id @default(uuid())
  participant1Id  String
  participant2Id  String
  listingId       String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lastMessageAt   DateTime?
  lastEmailSentAt DateTime? // Track when last email was sent for 1-hour cooldown

  participant1 User      @relation("ConversationParticipant1", fields: [participant1Id], references: [id], onDelete: Cascade)
  participant2 User      @relation("ConversationParticipant2", fields: [participant2Id], references: [id], onDelete: Cascade)
  listing      Listing?  @relation(fields: [listingId], references: [id], onDelete: SetNull)
  messages     Message[]

  @@unique([participant1Id, participant2Id, listingId])
  @@index([participant1Id])
  @@index([participant2Id])
  @@index([participant1Id, lastMessageAt]) // For user conversations
  @@index([participant2Id, lastMessageAt]) // For user conversations
  @@index([lastMessageAt]) // For sorting
  @@map("conversations")
}

model Message {
  id             String      @id @default(uuid())
  conversationId String
  senderId       String
  content        String      @db.Text
  messageType    MessageType @default(text)
  attachments    String[] // Array of file URLs
  readAt         DateTime?
  deliveredAt    DateTime?
  createdAt      DateTime    @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([conversationId, createdAt, readAt]) // Composite for unread queries
  @@index([senderId])
  @@index([senderId, createdAt]) // For user message queries
  @@index([readAt]) // For unread count queries
  @@map("messages")
}

model SavedSearch {
  id           String   @id @default(uuid())
  userId       String
  name         String
  searchParams Json // Store all search filters and parameters
  emailAlerts  Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("saved_searches")
}

model SearchHistory {
  id               String   @id @default(uuid())
  userId           String?
  searchQuery      String?
  filters          Json? // Store search filters
  resultsCount     Int      @default(0)
  clickedListingId String?
  createdAt        DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdAt])
  @@map("search_history")
}

model Otp {
  id        String   @id @default(uuid())
  email     String
  code      String   @db.VarChar(6)
  purpose   String   @default("registration") // registration, password_reset, etc.
  expiresAt DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email, purpose])
  @@index([email, code])
  @@index([expiresAt])
  @@map("otps")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}
